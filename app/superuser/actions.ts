'use server';

import { getTenantPrisma } from '@/lib/prisma';
import { revalidatePath } from 'next/cache';
import { logAudit } from '@/lib/audit';
import { auth } from '@/auth';

export async function saveEmailTemplate(formData: FormData) {
    const session = await auth();
    // @ts-ignore
    if (session?.user?.role !== 'SUPERUSER') {
        throw new Error('Unauthorized');
    }

    const id = formData.get('id') as string;
    const name = formData.get('name') as string;
    const subject = formData.get('subject') as string;
    const body = formData.get('body') as string;
    const variables = formData.get('variables') as string;

    if (!name || !subject || !body || !variables) {
        throw new Error('Missing required fields');
    }

    if (id && id !== 'new') {
        // Update existing
        await (await getTenantPrisma()).emailTemplate.update({
            where: { id: parseInt(id) },
            data: { subject, body, variables }
        });

        await logAudit({
            userId: session?.user?.id ? parseInt(session.user.id) : undefined,
            action: 'UPDATE',
            resource: 'EmailTemplate',
            details: `Updated template: ${name}`,
            severity: 'WARN'
        });
    } else {
        // Create new
        await (await getTenantPrisma()).emailTemplate.create({
            data: { name, subject, body, variables }
        });

        await logAudit({
            userId: session?.user?.id ? parseInt(session.user.id) : undefined,
            action: 'CREATE',
            resource: 'EmailTemplate',
            details: `Created template: ${name}`,
            severity: 'WARN'
        });
    }

    revalidatePath('/superuser');
}

export async function syncDatabaseSequences() {
    const session = await auth();
    // @ts-ignore
    if (session?.user?.role !== 'SUPERUSER') {
        throw new Error('Unauthorized');
    }

    const tables = [
        { table: 'Employee', pk: 'empId' },
        { table: 'Shift', pk: 'id' },
        { table: 'AssetCategory', pk: 'id' },
        { table: 'Asset', pk: 'id' },
        { table: 'AssetAssignment', pk: 'id' },
        { table: 'User', pk: 'id' },
        { table: 'RoleTemplate', pk: 'id' },
        { table: 'Training', pk: 'TrainingID' },
        { table: 'Attendance', pk: 'attendanceID' },
        { table: 'Certificate', pk: 'CertificateID' },
        { table: 'Policy', pk: 'id' },
        { table: 'PolicyAcknowledgment', pk: 'id' },
        { table: 'CertificateTrainingExclusion', pk: 'exclusionID' },
        { table: 'Expiration', pk: 'expirationID' },
        { table: 'FormTemplate', pk: 'id' },
        { table: 'FormSection', pk: 'id' },
        { table: 'FormField', pk: 'id' },
        { table: 'FormResponse', pk: 'id' },
        { table: 'EISFlag', pk: 'id' },
        { table: 'OrganizationSettings', pk: 'id' },
        { table: 'IssuedLicense', pk: 'id' },
        { table: 'EmailTemplate', pk: 'id' }
    ];

    let successCount = 0;
    const failures: string[] = [];

    for (const t of tables) {
        try {
            // Check if we can safely calculate MAX. 
            // In Prisma, we use queryRawUnsafe to skip schema typings for raw table access.
            const maxQuery: any[] = await (await getTenantPrisma()).$queryRawUnsafe(`SELECT MAX("${t.pk}") as max_val FROM "${t.table}";`);
            const maxVal = maxQuery[0]?.max_val || 0;

            // setval with pure integer advancing sequence to MAX + 1
            // pg_get_serial_sequence safely references sequences generated by Prisma.
            await (await getTenantPrisma()).$executeRawUnsafe(`
                SELECT setval(
                    pg_get_serial_sequence('"${t.table}"', '${t.pk}'), 
                    COALESCE(GREATEST(CAST(${maxVal} AS bigint), 1), 1), 
                    true
                );
            `);
            successCount++;
        } catch (e: any) {
            // Ignore SQLite errors naturally (as SQLite does not have pg_get_serial_sequence)
            const msg = e instanceof Error ? e.message : String(e);
            if (!msg.includes('no such function: pg_get_serial_sequence')) {
                failures.push(`Table ${t.table}: ${msg}`);
            }
        }
    }

    await logAudit({
        userId: session?.user?.id ? parseInt(session.user.id) : undefined,
        action: 'UPDATE',
        resource: 'Database',
        details: `Synchronized ${successCount} PostgreSQL sequences.`,
        severity: 'CRITICAL'
    });

    if (failures.length > 0) {
        return { success: false, message: `Synced ${successCount} tables, but encountered ${failures.length} errors.`, failures };
    }

    return { success: true, message: `Successfully synchronized ${successCount} table sequences! New records can now be created without ID conflicts.` };
}
